#!/bin/bash

cd `dirname $0`/..
export WORKDIR=`pwd`

. scripts/args-and-arch-check-functions.sh

# get the imagebuilder config
if [ -f scripts/imagebuilder.conf ]; then
  . scripts/imagebuilder.conf
fi

export BUILD_ROOT=/compile/local/imagebuilder-root
export DOWNLOAD_DIR=/compile/local/imagebuilder-download
export IMAGE_DIR=/compile/local/imagebuilder-diskimage
export MOUNT_POINT=/tmp/imagebuilder-mnt

if [ ! -d ${BUILD_ROOT} ]; then
  echo ""
  echo "build root dir ${BUILD_ROOT} does not exists - please run create-fs.sh first ..."
  echo ""
  exit 1
fi

if [ ! -d ${DOWNLOAD_DIR} ]; then
  echo ""
  echo "download dir ${DOWNLOAD_DIR} does not exists - please run get-files.sh first ..."
  echo ""
  exit 1
fi

# check that everything is there and set
if [ ! -x /usr/bin/unlz4 ]; then
  echo ""
  echo "unlz4 not found - please install the lz4 package - giving up"
  echo ""
  exit 1
fi
if [ ! -f systems/${1}/mbr-partitions.txt ] && [ ! -f systems/${1}/gpt-partitions.txt ]; then
  echo ""
  echo "systems/${1}/mbr-partitions.txt or systems/${1}/gpt-partitions.txt does not exist - giving up"
  echo ""
  exit 1
fi
if [ ! -f systems/${1}/partition-mapping.txt ]; then
  echo ""
  echo "systems/${1}/partition-mapping.txt does not exist - giving up"
  echo ""
  exit 1
else
  # get partition mapping info
  . systems/${1}/partition-mapping.txt
  # check that all required variables are set
  if [ "$BOOTFS" != "" ]; then
    echo "BOOTFS=$BOOTFS"
  else
    echo ""
    echo "BOOTFS is not set in systems/${1}/partition-mapping.txt - giving up"
    echo ""
    exit
  fi
  if [ "$ROOTFS" != "" ]; then
    echo "ROOTFS=$ROOTFS"
  else
    echo ""
    echo "ROOTFS is not set in systems/${1}/partition-mapping.txt - giving up"
    echo ""
    exit
  fi
  if [ "$ROOTFS" = "btrfs" ]; then
    if [ ! -x /bin/mkfs.btrfs ] && [ ! -x /usr/sbin/mkfs.btrfs ] && [ ! -x /sbin/mkfs.btrfs ] ; then
      echo ""
      echo "mkfs.btrfs is not available - please install the btrfs-progs package"
      echo ""
      exit 1
    fi
  fi
  if [ "$BOOTPART" != "" ]; then
    echo "BOOTPART=$BOOTPART"
  else
    echo ""
    echo "BOOTPART is not set in systems/${1}/partition-mapping.txt - giving up"
    echo ""
    exit
  fi
  if [ "$ROOTPART" != "" ]; then
    echo "ROOTPART=$ROOTPART"
  else
    echo ""
    echo "ROOTPART is not set in systems/${1}/partition-mapping.txt - giving up"
    echo ""
    exit
  fi
  if [ "$SWAPPART" != "" ]; then
    echo "SWAPPART=$SWAPPART"
  else
    echo ""
    echo "INFO: SWAPPART is not set in systems/${1}/partition-mapping.txt - this is ok"
    echo ""
  fi
  # from partition-mapping it is clear if this is a chromebook or not via CROSPARTS
  if [ "$CROSPARTS" != "" ]; then
    echo "CROSPARTS=$CROSPARTS"
  fi
  if [ "$CROSPARTS_LEGACY" != "" ]; then
    echo "CROSPARTS_LEGACY=$CROSPARTS_LEGACY"
  fi
  if [ "$PMOSKERNEL" != "" ]; then
    echo "PMOSKERNEL=$PMOSKERNEL"
  fi
  if [ "$UEFI32" != "" ]; then
    echo "UEFI32=$UEFI32"
  fi
  if [ "$UEFI64" != "" ]; then
    echo "UEFI64=$UEFI64"
  fi
  if [ "$MBR" != "" ]; then
    echo "MBR=$MBR"
  fi
  if [ "$UEFI64ARM" != "" ]; then
    echo "UEFI64ARM=$UEFI64ARM"
  fi
  if [ "$IMAGESIZE" != "" ]; then
    echo "IMAGESIZE=$IMAGESIZE"
  fi
fi

mkdir -p ${IMAGE_DIR}
if [ -d  ${MOUNT_POINT} ]; then
  echo ""
  echo "mount point ${MOUNT_POINT} already exists - giving up for safety reasons ..."
  echo ""
  exit 1
fi

mkdir -p ${MOUNT_POINT}

if [ -f ${IMAGE_DIR}/${1}-${2}-${3}.img ]; then
  echo ""
  echo "image file ${IMAGE_DIR}/${1}-${2}-${3}.img already exists - giving up for safety reasons ..."
  echo ""
  exit 1
fi

# we use less than the marketing capacity of the sd card as it is usually lower in reality 3.8/5.8gb
# the compressed btrfs root needs less space on disk
if [ "$IMAGESIZE" != "" ]; then
    truncate -s ${IMAGESIZE} ${IMAGE_DIR}/${1}-${2}-${3}.img
else
  if [ "$ROOTFS" = "btrfs" ]; then
    truncate -s 3892M ${IMAGE_DIR}/${1}-${2}-${3}.img
  else
    truncate -s 5940M ${IMAGE_DIR}/${1}-${2}-${3}.img
  fi
fi

losetup /dev/loop0 ${IMAGE_DIR}/${1}-${2}-${3}.img

# the arm chromebooks have some special boot partition setup
if [ "${CROSPARTS}" = "true" ] || [ "$CROSPARTS_LEGACY" = "true" ]; then

  # the fllowing part is based on
  # https://github.com/eballetbo/chromebooks/blob/master/chromebook-setup.sh
  # https://github.com/Maccraft123/Cadmium/blob/master/fs/install-to-emmc-begin

  # clear the partition table and reread it via partprobe
  sgdisk -Z /dev/loop0
  partprobe /dev/loop0

  # create a fresh partition table and reread it via partprobe
  sgdisk -C -e -G /dev/loop0
  partprobe /dev/loop0

  # create the chomeos partition structure and reread it via partprobe
  cgpt create /dev/loop0
  partprobe /dev/loop0

  # create two boot partitions and set them as bootable
  # two to have a second one to play around just in case
  # old chromebooks were limited to 32mb for them (32bit arm, gru, oak)
  # newer ones are limited to 512mb (kukui, trogdor and anything newer), but 128mb should be plenty for now
  if [ "${CROSPARTS_LEGACY}" = "true" ]; then
    cgpt add -i 1 -t kernel -b 8192 -s 65536 -l KernelA -S 1 -T 2 -P 10 /dev/loop0
    cgpt add -i 2 -t kernel -b 73728 -s 65536 -l KernelB -S 0 -T 2 -P 5 /dev/loop0
  else
    cgpt add -i 1 -t kernel -b 8192 -s 262144 -l KernelA -S 1 -T 2 -P 10 /dev/loop0
    cgpt add -i 2 -t kernel -b 270336 -s 262144 -l KernelB -S 0 -T 2 -P 5 /dev/loop0
  fi

# for all others the boot block is simply written to the beginning of the disk image
else
  if [ -f ${DOWNLOAD_DIR}/boot-${1}-${2}.dd ]; then
    dd if=${DOWNLOAD_DIR}/boot-${1}-${2}.dd of=/dev/loop0
  fi
fi

# in case of a postmarketos kernel other labels for boot and root partitions are used
if [ "$PMOSKERNEL" = "true" ]; then
  BOOTPARTLABEL="pmOS_boot"
  ROOTPARTLABEL="pmOS_root"
else
  BOOTPARTLABEL="bootpart"
  ROOTPARTLABEL="rootpart"
fi

# inspired by https://github.com/jeromebrunet/libretech-image-builder/blob/libretech-cc-xenial-4.13/linux-image.sh
if [ -f systems/${1}/mbr-partitions.txt ]; then
  fdisk /dev/loop0 < systems/${1}/mbr-partitions.txt
elif [ -f systems/${1}/gpt-partitions.txt ]; then
  fdisk /dev/loop0 < systems/${1}/gpt-partitions.txt
fi

# this is to make sure we really use the new partition table and have all partitions around
partprobe /dev/loop0
losetup -d /dev/loop0
losetup --partscan /dev/loop0 ${IMAGE_DIR}/${1}-${2}-${3}.img

# not sure if this helps, but this is the try to avoid the random cases of
# the loop devices not being ready yet from time to time
sync
sleep 10
sync

# for chromebooks write the kernel to the first kernel partition
# replaced by a velvet-tools based approach further down below for aarch64 chromebooks
if ([ "${CROSPARTS_LEGACY}" = "true" ] || [ "${CROSPARTS}" = "true" ]) && [ "$(cat ${DOWNLOAD_DIR}/arch.txt)" = "armv7l" ]; then
  dd if=${DOWNLOAD_DIR}/boot-${1}-${2}.dd of=/dev/loop0p1 status=progress
fi

if [ "$BOOTFS" = "fat" ]; then
  mkfs.vfat -F32 -n BOOTPART /dev/loop0p$BOOTPART
elif [ "$BOOTFS" = "ext2" ]; then
  mkfs -t ext2 -m 0 -L $BOOTPARTLABEL /dev/loop0p$BOOTPART
elif [ "$BOOTFS" = "ext4" ]; then
  mkfs -t ext4 -O ^has_journal -m 0 -L $BOOTPARTLABEL /dev/loop0p$BOOTPART
fi

if [ "$ROOTFS" = "btrfs" ]; then
  mkfs -t btrfs -m single -L $ROOTPARTLABEL /dev/loop0p$ROOTPART
  mount -o ssd,compress-force=zstd,noatime,nodiratime /dev/loop0p$ROOTPART ${MOUNT_POINT}
else
  mkfs -t ext4 -O ^has_journal -m 2 -L $ROOTPARTLABEL /dev/loop0p$ROOTPART
  mount /dev/loop0p$ROOTPART ${MOUNT_POINT}
fi
mkdir ${MOUNT_POINT}/boot
mount /dev/loop0p$BOOTPART ${MOUNT_POINT}/boot
if [ "${UEFI32}" = "true" ] || [ "${UEFI64}" = "true" ] || [ "${UEFI64ARM}" = "true" ]; then
  mkfs -t vfat -F 32 -n EFI /dev/loop0p1
  mkdir -p ${MOUNT_POINT}/boot/efi
  mount /dev/loop0p1 ${MOUNT_POINT}/boot/efi
fi

echo "copying over the root fs to the target image - this may take a while ..."
date
rsync -axADHSX --no-inc-recursive ${BUILD_ROOT}/ ${MOUNT_POINT}
date
echo "done"

if [ "$SWAPPART" != "" ]; then
  mkswap -L swappart /dev/loop0p$SWAPPART
else
  if [ "$ROOTFS" = "btrfs" ]; then
    btrfs subvolume create ${MOUNT_POINT}/swap
    chmod 755 ${MOUNT_POINT}/swap
    chattr -R +C ${MOUNT_POINT}/swap
  else
    mkdir ${MOUNT_POINT}/swap
  fi
  truncate -s 0 ${MOUNT_POINT}/swap/file.0
  fallocate -l 512M ${MOUNT_POINT}/swap/file.0
  chmod 600 ${MOUNT_POINT}/swap/file.0
  mkswap -L swapfile.0 ${MOUNT_POINT}/swap/file.0
  sed -i 's,LABEL=swappart,/swap/file.0,g' ${MOUNT_POINT}/etc/fstab
fi

# create a customized fstab file
cp /dev/null ${MOUNT_POINT}/etc/fstab
# the pmos initramfs is premounting /boot already, so no need to mount it via fstab
if [ "$PMOSKERNEL" = "true" ]; then
  FSTAB_EXT4_BOOT="LABEL=$BOOTPARTLABEL /boot ext4 defaults,noatime,nodiratime,errors=remount-ro,noauto 0 2"
  FSTAB_EXT2_BOOT="LABEL=$BOOTPARTLABEL /boot ext2 defaults,noatime,nodiratime,errors=remount-ro,noauto 0 2"
else
  FSTAB_EXT4_BOOT="LABEL=$BOOTPARTLABEL /boot ext4 defaults,noatime,nodiratime,errors=remount-ro 0 2"
  FSTAB_EXT2_BOOT="LABEL=$BOOTPARTLABEL /boot ext2 defaults,noatime,nodiratime,errors=remount-ro 0 2"
fi
# pmos kernels do not use fat boot partitions, so the name can be hardcoded here
FSTAB_VFAT_BOOT="LABEL=BOOTPART /boot vfat defaults,rw,flush,umask=000 0 0"
FSTAB_BTRFS_ROOT="LABEL=$ROOTPARTLABEL / btrfs defaults,ssd,compress-force=zstd,noatime,nodiratime 0 1"
FSTAB_EXT4_ROOT="LABEL=$ROOTPARTLABEL / ext4 defaults,noatime,nodiratime,errors=remount-ro 0 1"
FSTAB_SWAP_FILE="/swap/file.0 none swap sw 0 0"
FSTAB_SWAP_PART="LABEL=swappart none swap sw 0 0"
if [ "${UEFI32}" = "true" ] || [ "${UEFI64}" = "true" ] || [ "${UEFI64ARM}" = "true" ]; then
  FSTAB_VFAT_EFI="LABEL=EFI /boot/efi vfat umask=0077 0 1"
  echo $FSTAB_VFAT_EFI >> ${MOUNT_POINT}/etc/fstab
fi

if [ "$BOOTFS" = "ext4" ]; then
  echo $FSTAB_EXT4_BOOT >> ${MOUNT_POINT}/etc/fstab
elif [ "$BOOTFS" = "ext2" ]; then
  echo $FSTAB_EXT2_BOOT >> ${MOUNT_POINT}/etc/fstab
else
  echo $FSTAB_VFAT_BOOT >> ${MOUNT_POINT}/etc/fstab
fi
if [ "$ROOTFS" = "btrfs" ]; then
  echo $FSTAB_BTRFS_ROOT >> ${MOUNT_POINT}/etc/fstab
else
  echo $FSTAB_EXT4_ROOT >> ${MOUNT_POINT}/etc/fstab
fi
if [ "$SWAPPART" = "" ]; then
  echo $FSTAB_SWAP_FILE >> ${MOUNT_POINT}/etc/fstab
else
  echo $FSTAB_SWAP_PART >> ${MOUNT_POINT}/etc/fstab
fi

# TODO: the r89 and uEnv.ini sections are special to orbsmart_s92_beelink_r89 and amlogic_m8
#       only and should thus be converted to finalize-chroot.sh scripts now that those exist
if [ "$PMOSKERNEL" != "true" ]; then
  if [ "${2}" = "armv7l" ] || [ "${2}" = "aarch64" ]; then
    export KERNEL_VERSION=`ls ${BUILD_ROOT}/boot/*Image-* | sed 's,.*Image-,,g' | sort -u`
    if [ "$PARTUUID_ROOT" = "YES" ]; then
      ROOT_PARTUUID=$(blkid | grep "/dev/loop0p$ROOTPART" | awk '{print $5}' | sed 's,",,g')
      if [ -f ${MOUNT_POINT}/boot/extlinux/extlinux.conf ]; then
        sed -i "s,ROOT_PARTUUID,$ROOT_PARTUUID,g" ${MOUNT_POINT}/boot/extlinux/extlinux.conf
        sed -i "s,KERNEL_VERSION,$KERNEL_VERSION,g" ${MOUNT_POINT}/boot/extlinux/extlinux.conf
      fi
      if [ -f ${MOUNT_POINT}/boot/menu/extlinux.conf ]; then
        sed -i "s,ROOT_PARTUUID,$ROOT_PARTUUID,g" ${MOUNT_POINT}/boot/menu/extlinux.conf
        sed -i "s,KERNEL_VERSION,$KERNEL_VERSION,g" ${MOUNT_POINT}/boot/menu/extlinux.conf
      fi
      if [ -f ${MOUNT_POINT}/boot/r89-boot/parameter-linux ]; then
        sed -i "s,ROOT_PARTUUID,$ROOT_PARTUUID,g" ${MOUNT_POINT}/boot/r89-boot/parameter-linux
        sed -i "s,KERNEL_VERSION,$KERNEL_VERSION,g" ${MOUNT_POINT}/boot/r89-boot/parameter-linux
      fi
      if [ -f ${MOUNT_POINT}/boot/uEnv.ini ]; then
        sed -i "s,ROOT_PARTUUID,$ROOT_PARTUUID,g" ${MOUNT_POINT}/boot/uEnv.ini
        sed -i "s,KERNEL_VERSION,$KERNEL_VERSION,g" ${MOUNT_POINT}/boot/uEnv.ini
      fi
    else
      if [ -f ${MOUNT_POINT}/boot/extlinux/extlinux.conf ]; then
        sed -i "s,ROOT_PARTUUID,LABEL=$ROOTPARTLABEL,g" ${MOUNT_POINT}/boot/extlinux/extlinux.conf
        sed -i "s,KERNEL_VERSION,$KERNEL_VERSION,g" ${MOUNT_POINT}/boot/extlinux/extlinux.conf
      fi
      if [ -f ${MOUNT_POINT}/boot/menu/extlinux.conf ]; then
        sed -i "s,ROOT_PARTUUID,LABEL=$ROOTPARTLABEL,g" ${MOUNT_POINT}/boot/menu/extlinux.conf
        sed -i "s,KERNEL_VERSION,$KERNEL_VERSION,g" ${MOUNT_POINT}/boot/menu/extlinux.conf
      fi
      if [ -f ${MOUNT_POINT}/boot/r89-boot/parameter-linux ]; then
        sed -i "s,ROOT_PARTUUID,LABEL=$ROOTPARTLABEL,g" ${MOUNT_POINT}/boot/r89-boot/parameter-linux
        sed -i "s,KERNEL_VERSION,$KERNEL_VERSION,g" ${MOUNT_POINT}/boot/r89-boot/parameter-linux
      fi
      if [ -f ${MOUNT_POINT}/boot/uEnv.ini ]; then
        sed -i "s,ROOT_PARTUUID,LABEL=$ROOTPARTLABEL,g" ${MOUNT_POINT}/boot/uEnv.ini
        sed -i "s,KERNEL_VERSION,$KERNEL_VERSION,g" ${MOUNT_POINT}/boot/uEnv.ini
      fi
    fi
  elif [ "${2}" = "riscv64" ]; then
    export KERNEL_VERSION=`ls ${BUILD_ROOT}/boot/*Image-* | sed 's,.*Image-,,g' | sort -u`
    # in case we did not get a kernel version, try it again with the vmlinuz
    if [ "$KERNEL_VERSION" = "" ]; then
      echo "trying vmlinuz as kernel name instead of *Image:"
      export KERNEL_VERSION=`ls ${BUILD_ROOT}/boot/vmlinuz-* | sed 's,.*vmlinuz-,,g' | sort -u`
    fi
    if [ "$KERNEL_VERSION" = "" ]; then
      echo ""
      echo "no KERNEL_VERSION detected - this is most probably a problem and should be fixed"
      echo ""
    fi
    if [ "$PARTUUID_ROOT" = "YES" ]; then
      ROOT_PARTUUID=$(blkid | grep "/dev/loop0p$ROOTPART" | awk '{print $5}' | sed 's,",,g')
      if [ -f ${MOUNT_POINT}/boot/extlinux/extlinux.conf ]; then
        sed -i "s,ROOT_PARTUUID,$ROOT_PARTUUID,g" ${MOUNT_POINT}/boot/extlinux/extlinux.conf
        sed -i "s,KERNEL_VERSION,$KERNEL_VERSION,g" ${MOUNT_POINT}/boot/extlinux/extlinux.conf
      fi
      if [ -f ${MOUNT_POINT}/boot/uEnv.ini ]; then
        sed -i "s,ROOT_PARTUUID,$ROOT_PARTUUID,g" ${MOUNT_POINT}/boot/uEnv.ini
        sed -i "s,KERNEL_VERSION,$KERNEL_VERSION,g" ${MOUNT_POINT}/boot/uEnv.ini
      fi
    else
      if [ -f ${MOUNT_POINT}/boot/extlinux/extlinux.conf ]; then
        sed -i "s,ROOT_PARTUUID,LABEL=$ROOTPARTLABEL,g" ${MOUNT_POINT}/boot/extlinux/extlinux.conf
        sed -i "s,KERNEL_VERSION,$KERNEL_VERSION,g" ${MOUNT_POINT}/boot/extlinux/extlinux.conf
      fi
      if [ -f ${MOUNT_POINT}/boot/uEnv.ini ]; then
        sed -i "s,ROOT_PARTUUID,LABEL=$ROOTPARTLABEL,g" ${MOUNT_POINT}/boot/uEnv.ini
        sed -i "s,KERNEL_VERSION,$KERNEL_VERSION,g" ${MOUNT_POINT}/boot/uEnv.ini
      fi
    fi
  fi
fi

# TODO: this should move to the system postinstall
# for the orbsmart s92 / beelink r89 the boot loader has to be written in a special way to the disk
if [ "$1" = "orbsmart_s92_beelink_r89" ]; then
  ${WORKDIR}/scripts/orbsmart_s92_beelink_r89-prepare-boot.sh ${KERNEL_VERSION}
  ${WORKDIR}/scripts/orbsmart_s92_beelink_r89-create-boot.sh
fi

# TODO: this should move to the system postinstall
# for the amlogic m8x we will have to shorten the kernel and initrd filenames due to a 23 char limit
if [ "$1" = "amlogic_m8" ]; then
  ${MOUNT_POINT}/boot/shorten-filenames.sh
fi

# prepare for a complete chroot env partially needed by the following steps
mount -o bind /dev ${MOUNT_POINT}/dev
mount -o bind /dev/pts ${MOUNT_POINT}/dev/pts
mount -o bind /run ${MOUNT_POINT}/run
mount -t sysfs /sys ${MOUNT_POINT}/sys
mount -t proc /proc ${MOUNT_POINT}/proc

# do this to avoid failing apt installs due to a too old fs-cache
chroot ${MOUNT_POINT} apt-get update

# preparation and installation of the kernel + initrd via velvet-tools on aarch64 chromebooks
if ([ "${CROSPARTS_LEGACY}" = "true" ] || [ "${CROSPARTS}" = "true" ]) && [ "$(cat ${DOWNLOAD_DIR}/arch.txt)" = "aarch64" ]; then
  chroot ${MOUNT_POINT} apt-get -y install velvet-tools
  export KERNEL_VERSION=$( ls ${MOUNT_POINT}/boot/*Image-* | sed 's,.*Image-,,g' | sort -u )
  chroot ${MOUNT_POINT} vtbuild ${KERNEL_VERSION}
  chroot ${MOUNT_POINT} vtflash ${KERNEL_VERSION} yes
fi

if [ "${UEFI32}" = "true" ]; then
  chroot ${MOUNT_POINT} apt-get -yq install grub2-common grub-efi-ia32 grub-efi-ia32-bin
  chroot ${MOUNT_POINT} grub-install --target=i386-efi /dev/loop0p1 --efi-directory=/boot/efi/ --boot-directory=/boot/
  # debian needs some extra steps to enable fallback boot sometimes required to boot from external media
  if [ "$3" = "bookworm" ] || [ "${3}" = "trixie" ]; then
    chroot ${MOUNT_POINT} mkdir -p /boot/efi/EFI/BOOT
    chroot ${MOUNT_POINT} cp /boot/efi/EFI/debian/grubia32.efi /boot/efi/EFI/BOOT/BOOTIA32.EFI
    chroot ${MOUNT_POINT} cp /usr/share/images/desktop-base/desktop-grub.png /boot/grub
  fi
fi

if [ "${UEFI64}" = "true" ]; then
  chroot ${MOUNT_POINT} apt-get -yq install grub2-common grub-efi-amd64 grub-efi-amd64-bin
  chroot ${MOUNT_POINT} grub-install --target=x86_64-efi /dev/loop0p1 --efi-directory=/boot/efi/ --boot-directory=/boot/
  # debian needs some extra steps to enable fallback boot sometimes required to boot from external media
  if [ "$3" = "bookworm" ] || [ "${3}" = "trixie" ]; then
    chroot ${MOUNT_POINT} mkdir -p /boot/efi/EFI/BOOT
    chroot ${MOUNT_POINT} cp /boot/efi/EFI/debian/grubx64.efi /boot/efi/EFI/BOOT/BOOTX64.EFI
    chroot ${MOUNT_POINT} cp /usr/share/images/desktop-base/desktop-grub.png /boot/grub
  fi
fi

if [ "${MBR}" = "true" ]; then
  chroot ${MOUNT_POINT} apt-get -yq install grub2-common grub-pc grub-pc-bin
  chroot ${MOUNT_POINT} grub-install /dev/loop0
fi

# this currently would only be used by snapdragon_xyz systems and does not seem to work yet with
# the native arm64 grub included in debian and ubuntu so it is made to fail currently by
# specifying the not existing /boot/selected.dtb
# TODO: check if this is still the case
if [ "${UEFI64ARM}" = "true" ]; then
  chroot ${MOUNT_POINT} apt-get -yq install grub2-common grub-efi-arm64 grub-efi-arm64-bin
  chroot ${MOUNT_POINT} grub-install --target=arm64-efi /dev/loop0p1 --efi-directory=/boot/efi/ --boot-directory=/boot/ --no-nvram --no-bootsector --dtb=/boot/selected.dtb --removable
  # debian needs some extra steps to enable fallback boot sometimes required to boot from external media
  if [ "$3" = "bookworm" ] || [ "${3}" = "trixie" ]; then
# lets not do this yet as long as that special grub version is still used via
# the systems extra-files/boot for the aarch64 images - maybe its time to check
# if the regular debian/ubuntu grub is meanwhile working well enough on aarch64?
#    chroot ${MOUNT_POINT} mkdir -p /boot/efi/EFI/BOOT
#    #chroot ${MOUNT_POINT} cp /boot/efi/EFI/debian/grubaa64.efi /boot/efi/EFI/BOOT/BOOTAA64.EFI
#    chroot ${MOUNT_POINT} cp /boot/efi/EFI/debian/grubaa64.efi /boot/efi/EFI/BOOT/grubaa64.efi
#    chroot ${MOUNT_POINT} cp /boot/efi/EFI/debian/fbaa64.efi /boot/efi/EFI/BOOT/fbaa64.efi
    chroot ${MOUNT_POINT} cp /usr/share/images/desktop-base/desktop-grub.png /boot/grub
  fi
fi

# TODO: maybe move the update-initramfs from create-fs here ...

if [ "${UEFI32}" = "true" ] || [ "${UEFI64}" = "true" ] || [ "${MBR}" = "true" ] || [ "${UEFI64ARM}" = "true" ]; then
  # grub config script per system
  if [ -f ${WORKDIR}/systems/${1}/grubconfig.sh ]; then
    cp ${WORKDIR}/systems/${1}/grubconfig.sh ${MOUNT_POINT}/grubconfig.sh
    chmod a+x ${MOUNT_POINT}/grubconfig.sh
    chroot ${MOUNT_POINT} /grubconfig.sh
    rm -f ${MOUNT_POINT}/grubconfig.sh
  fi
  chroot ${MOUNT_POINT} update-grub
fi

# finalize script which is run chrooted per system
if [ -f ${WORKDIR}/systems/${1}/finalize-chroot.sh ]; then
  cp ${WORKDIR}/systems/${1}/finalize-chroot.sh ${MOUNT_POINT}/finalize-chroot.sh
  chmod a+x ${MOUNT_POINT}/finalize-chroot.sh
  chroot ${MOUNT_POINT} /finalize-chroot.sh ${1} ${2} ${3}
  rm -f ${MOUNT_POINT}/finalize-chroot.sh
fi

# create a useable default /etc/resolv.conf instead of the one from the build system
# it will usually be overwritten with something more useful via dhcp etc.
echo "nameserver 1.1.1.1" > ${MOUNT_POINT}/etc/resolv.conf

# umount all the extra stuff mounted for chroot usage as we are done with chroots now
umount ${MOUNT_POINT}/proc ${MOUNT_POINT}/sys ${MOUNT_POINT}/run ${MOUNT_POINT}/dev/pts ${MOUNT_POINT}/dev

if [ "${UEFI32}" = "true" ] || [ "${UEFI64}" = "true" ] || [ "${UEFI64ARM}" = "true" ]; then
  df -h ${MOUNT_POINT} ${MOUNT_POINT}/boot ${MOUNT_POINT}/boot/efi
  umount ${MOUNT_POINT}/boot/efi
else
  df -h ${MOUNT_POINT} ${MOUNT_POINT}/boot
fi
umount ${MOUNT_POINT}/boot
umount ${MOUNT_POINT}

losetup -d /dev/loop0

rmdir ${MOUNT_POINT}

echo ""
echo "the image is now ready at ${IMAGE_DIR}/${1}-${2}-${3}.img"
echo ""
